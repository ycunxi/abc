/*
Maintained by Walter Brown
Open for modification to others in Maciej Ciesielski's team.
An expression boss performs substitutions in an expression.
*/

#ifndef _EXPRESSION_BOSS_GUARD_
#define _EXPRESSION_BOSS_GUARD_

#include "expression.h"
#include <gmpxx.h>
#include <set>
#include <stack>
#include <string>
#include "stringmath.h"
#include <unordered_map>

using namespace std;

class ExpressionBoss
{
  public:
    class Substitution
    {
      public:
        Substitution();
        Substitution(const string& replacement);
        Expression replacement;
        mpz_class level;
        /*
        The number of substitutions that depend on this substitution, which is
        probably greater than the number of variables in the replacement.
        */
        mpz_class dependentCount;
        /* Variables within substitution. */
        set<string> variables;
        /*
        These are the names of the wires in the direct logical cone of this
        wire.  In other words, these are the substitutions that have this
        substitution in their replacement.  This is built and disassembled
        while levelizing.
        */
        set<string> dependencyStack;
        /*
        Indicates that this substitution already happened in the current
        operation.
        */
        bool happened;
    };

    ExpressionBoss(void);

    /*
    Like inputSignature, but uses the order substitutions were learned rather
    than using levelization or any "technique."
    */
    string blind(const string& outputSignature);
    void blind(Expression& outputSignature);

    /*
    Like inputSignature, but chooses substitutions by trying to minimize the
    number of substitutions that will be added by the substitution,
    pre-cancellations.  This value will always be positive.
    */
    string cheapGreed(const string& outputSignature);
    void cheapGreed(Expression& outputSignature);

    /* 
    Forgets all substitutions.
    */
    void clear(void);

    /*
    Uses a version of levelization based on dijkstra.
    TODO:  Not incorperated into petBoss yet, coming soon! 
    */
    string dijkstra(const string& outputSignature);
    void dijkstra(Expression& outputSignature);

    /*
    Returns an ordered *.eqn file based on the substitutions that have happend
    so far.  This will also clear the buffer that is used for this purpose.
    */
    vector<string> dumpEQN();

    /*
    Like inputSignature, but chooses the substitution that will make the
    expression the smallest.
    */
    string expensiveGreed(const string& outputSignature);
    void expensiveGreed(Expression& outputSignature);

    /*
    Returns the current known substitutions.
    */
    unordered_map<string, Substitution> getSubstitutionTable();

    /*
    Returns the input signature generated by the given output signature, using
    the substitutions provided.  The ordering technique is unspecified.
    */
    string inputSignature(const string& outputSignature);
    /* Converts input Expression to input signature. */
    void inputSignature(Expression& outputSignature);

    /*
    Returns true if the specified variable is a primary input, meaning it has
    no substitution recorded in this ExpressionBoss.
    */
    bool isPrimaryInput(const string);

    /*
    Adds a substitution the Boss can use.  Substitutions can be learned in any
    order.
    */
    void learnSubstitution(const string& var, const string& replacement);

    /*
    Clone of inputSignature.  More explicit.  Uses levelization to choose order.
    */
    string levelization(const string& outputSignature);
    void levelization(Expression& outputSignature);

    /*
    Forces a signal to become a primary input by forgetting the substitute for
    it.
    */
    void makePrimaryInput(const string& newPrimaryInput);

    /*
    Performs substitutions on two expressions and returns true if they match.
    */
    bool match(const string&, const string&);
    /* Warning:  Expressions will be mutated! */
    bool match(Expression&, Expression&);

    /*
    Like inputSignature, but chooses substitutions that satisfy the most
    dependencies.
    */
    string maxDependents(const string& outputSignature);
    void maxDependents(Expression& outputSignature);

    /*
    Can be used to disable the actual substitution phase.
    */
    void setDoSubstitute(bool);

  private:
    /* Always returns false. */
    bool alwaysFalse(const string&);

    /* This is the names of the wires in the order they were learned. */
    list<string> blindOrder;

    /* Builds the dependency stacks, properly cropping floats. */
    void buildDependencyStacks(set<string> primaryOutputs);
    /* Assumes all floats are primary outputs. */
    void buildDependencyStacks();

    /* Spreads the notifications of buildDependencyStacks upwards. */
    void buildDependencyStacksPropagate(const string&);

    /* Returns true if a wire has unmet dependencies. */
    bool dependenciesUnsatisfied(const string&);

    /* Debug function that prints the dependency stacks. */
    void describeDependency();
    void describeDependency(const string&);

    /* Debug function that prints the current substitution table. */
    void describeTable() const;

    /* This does nothing. */
    void dud(const string&);

    /* Sets dependencyCount for all substitutions. */
    void findDependentCount();
    mpz_class findDependentCount(const string&);
    
    /* Builds eqn files. */
    vector<string> eqnBuffer;
    void loadToEQN(const string&);

    /*
    Executes the input function for each wire name, in order of substitution.
    */
    void substituteUntilDoneLevel(Expression& outputSignature,
                 void (ExpressionBoss::*inFunction)(const string&));

    /*
    Returns the level value associated with a given wire, assuming it's been
    computed beforehand.  This is for use in substituteUntilDone.
    */
    mpz_class getLevel(const string&, const Expression&);

    /*
    Returns the negative version of dependentCount, which is computed
    beforehand.  This is for use in substituteUntilDone.
    */
    mpz_class negativeDependentCount(const string&, const Expression&);

    /*
    Will offer each signal in logicCone a new level (offer).  Then, the signals
    above may be updated as well.
    */
    void propagateLevel(const set<string> logicCone);

    /* Records substitutions. */
    unordered_map<string, Substitution> substitutionTable;

    /*
    Performs the upkeep associated with a substitution.
    */
    void substituteFor(const string& target, Expression& signature,
                       set<string>& varsAllowed,
                       void (ExpressionBoss::*inFunction)(const string&));

    /*
    Perform substitutions in the outputSignature until the outputSignature is
    in terms of primary inputs. varsAllowed is the list of variables starting
    in outputSignature.  inFunction is run every time a substitution is made.
    A wire's substitution won't be considered until it's filterFunction
    evaluates to false.  Substitutions are greedly chosen using minimizeMe.
    */
    void substituteUntilDone(Expression& outputSignature,
      set<string> varsAllowed,
      void (ExpressionBoss::*inFunction)(const string&),
      bool (ExpressionBoss::*filterFunction)(const string&),
      mpz_class(ExpressionBoss::*minimizeMe)(const string&, const Expression&));

    /*
    Like substituteUntilDone, but dependency is enforced.
    */
    void substituteUntilDoneDependency(Expression& outputSignature,
      set<string> varsAllowed,
      void (ExpressionBoss::*inFunction)(const string&),
      mpz_class(ExpressionBoss::*minimizeMe)(const string&, const Expression&));

    /* Returns (number of terms in replacement)*(occurances of variable). */
    mpz_class termsAddedBy(const string&, const Expression&);

   /*
   Returns the number of terms in Expression after substituting for string.
   */
    mpz_class termsAfter(const string&, const Expression&);

    bool doSubstitute;
};
#endif
